<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moving Red Cloud Background</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
    }
    /* Full-viewport canvas */
    #dark-veil-canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }
  </style>
</head>
<body>
  <canvas id="dark-veil-canvas"></canvas>

  <script>
    (function () {
      'use strict';

      function createShader(gl, type, source) {
        const shader = gl.createShader(type);
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        if (!gl.getShaderParameter(shader, gl.COMPPILE_STATUS)) {
          console.error('Shader compilation error:', gl.getShaderInfoLog(shader));
          return null;
        }
        return shader;
      }

      function createProgram(gl, vertexShader, fragmentShader) {
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
          console.error('Program linking error:', gl.getProgramInfoLog(program));
          return null;
        }
        return program;
      }

      const vertex = `
        attribute vec2 position;
        void main() { gl_Position = vec4(position, 0.0, 1.0); }
      `;

      const fragment = `
        precision mediump float;
        uniform vec2 uResolution;
        uniform float uTime;
        uniform float uHueShift;
        uniform float uNoise;
        uniform float uScan;
        uniform float uScanFreq;
        uniform float uWarp;

        float rand(vec2 c) {
          return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);
        }
        vec3 hsl2rgb(vec3 c) {
          vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
          return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));
        }
        float noise(vec2 p) {
          return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
        }
        float smoothNoise(vec2 p) {
          vec2 i = floor(p);
          vec2 f = fract(p);
          f = f * f * (3.0 - 2.0 * f);
          return mix(mix(noise(i), noise(i + vec2(1.0, 0.0)), f.x),
                     mix(noise(i + vec2(0.0, 1.0)), noise(i + vec2(1.0, 1.0)), f.x), f.y);
        }
        float fbm(vec2 p) {
          float v = 0.0;
          float a = 0.5;
          for (int i = 0; i < 5; i++) { v += a * smoothNoise(p); p *= 2.0; a *= 0.5; }
          return v;
        }

        void main() {
          vec2 uv = gl_FragCoord.xy / uResolution.xy;
          uv = uv * 2.0 - 1.0;
          uv.y *= -1.0;

          uv += uWarp * 0.01 * vec2(sin(uv.y * 6.283 + uTime * 0.5),
                                    cos(uv.x * 6.283 + uTime * 0.5));

          vec2 p = uv * 2.0 + vec2(uTime * 0.1, uTime * 0.05);
          float pattern1 = fbm(p);
          float pattern2 = fbm(p + vec2(uTime * 0.15, -uTime * 0.1));
          float pattern3 = fbm(p * 1.5 + vec2(-uTime * 0.08, uTime * 0.12));
          float combined = smoothstep(0.3, 0.8, pattern1 * 0.6 + pattern2 * 0.3 + pattern3 * 0.1);

          float hue = uHueShift / 360.0;
          vec3 baseColor = hsl2rgb(vec3(hue, 0.9, 0.6));
          vec3 color = baseColor * combined;

          float scanline = sin(gl_FragCoord.y * uScanFreq * 6.283) * 0.5 + 0.5;
          color *= 1.0 - (1.0 - scanline) * uScan * 0.3;
          color += (rand(gl_FragCoord.xy + uTime) - 0.5) * uNoise;

          gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
        }
      `;

      function init() {
        const canvas = document.getElementById('dark-veil-canvas');
        const gl = canvas && (canvas.getContext('webgl') || canvas.getContext('experimental-webgl'));
        if (!gl) return;

        const vs = createShader(gl, gl.VERTEX_SHADER, vertex);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, fragment);
        const program = vs && fs && createProgram(gl, vs, fs);
        if (!program) return;

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]), gl.STATIC_DRAW);

        const positionLocation = gl.getAttribLocation(program, 'position');
        const uniforms = {
          uTime: gl.getUniformLocation(program, 'uTime'),
          uResolution: gl.getUniformLocation(program, 'uResolution'),
          uHueShift: gl.getUniformLocation(program, 'uHueShift'),
          uNoise: gl.getUniformLocation(program, 'uNoise'),
          uScan: gl.getUniformLocation(program, 'uScan'),
          uScanFreq: gl.getUniformLocation(program, 'uScanFreq'),
          uWarp: gl.getUniformLocation(program, 'uWarp'),
        };

        function resize() {
          const dpr = Math.max(1, window.devicePixelRatio || 1);
          const w = Math.floor(window.innerWidth * dpr);
          const h = Math.floor(window.innerHeight * dpr);
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w; canvas.height = h;
            canvas.style.width = window.innerWidth + 'px';
            canvas.style.height = window.innerHeight + 'px';
            gl.viewport(0, 0, w, h);
            gl.useProgram(program);
            gl.uniform2f(uniforms.uResolution, w, h);
          }
        }
        window.addEventListener('resize', resize);
        resize();

        const start = performance.now();
        function render() {
          const t = (performance.now() - start) / 1000;
          gl.useProgram(program);
          gl.uniform1f(uniforms.uTime, t * 0.9);
          gl.uniform1f(uniforms.uHueShift, 0.0);  // 0 = red
          gl.uniform1f(uniforms.uNoise, 0.05);
          gl.uniform1f(uniforms.uScan, 1.0);
          gl.uniform1f(uniforms.uScanFreq, 0.5);
          gl.uniform1f(uniforms.uWarp, 5.0);

          gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
          gl.enableVertexAttribArray(positionLocation);
          gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
          gl.drawArrays(gl.TRIANGLES, 0, 6);

          requestAnimationFrame(render);
        }
        render();
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    })();
  </script>
</body>
</html>
